vim: sw=2

=================
plain identifiers
=================

fOo
f_0___
ü•∫
„ÅÇ„ÅÑ„ÅÜ„Åà„Åä

---

(source_file
  (identifier)
  (identifier)
  (identifier)
  (identifier))

============================
instance and class variables
============================

class Klass
  @a = 87
  @@b = "hjkl"

  def initialize(@a)
    puts @a + 2
  end

  def set_class_var(@@b)
  end
end

---
(source_file
  (class_def name: (constant)
    (assign lhs: (instance_var) rhs: (integer))
    (assign lhs: (class_var) rhs: (string))

    (method_def
      name: (identifier)
      params: (param_list (param name: (instance_var)))
      (call
        method: (identifier)
        arguments: (argument_list
          (op_call
            receiver: (instance_var)
            operator: (operator)
            argument: (integer)))))

    (method_def
      name: (identifier)
      params: (param_list (param name: (class_var))))))

====
self
====

self
self_
selfself

---

(source_file
  (self)
  (identifier)
  (identifier))

================
pseudo-constants
================

def pseudo_constants(caller_line = __LINE__, end_of_caller = __END_LINE__)
  puts "Called from line number: #{caller_line}"
  puts "Currently at line number: #{__LINE__}"
  puts "End of caller block is at: #{end_of_caller}"
  puts "File path is: #{__FILE__}"
  puts "Directory file is in: #{__DIR__}"
end

---
(source_file
  (method_def
    name: (identifier)
    params: (param_list
      (param name: (identifier) default: (pseudo_constant))
      (param name: (identifier) default: (pseudo_constant)))

    (call
      method: (identifier)
      arguments: (argument_list
        (string
          (interpolation
            (identifier)))))
    (call
      method: (identifier)
      arguments: (argument_list
        (string
          (interpolation
            (pseudo_constant)))))
    (call
      method: (identifier)
      arguments: (argument_list
        (string
          (interpolation
            (identifier)))))
    (call
      method: (identifier)
      arguments: (argument_list
        (string
          (interpolation
            (pseudo_constant)))))
    (call
      method: (identifier)
      arguments: (argument_list
        (string
          (interpolation
            (pseudo_constant)))))))

============
method calls
============

A.b

e()
c?
d!()

true.false?

m1?.m2

puts(b)

a b 7

a!.b!.c!

a b.c

a(b(c()))

pp a # comment
     # comment
  .  # asdf
     # comment
  b  # one more comment

---

(source_file
  (call
    receiver: (constant)
    method: (identifier))

  (call method: (identifier) arguments: (argument_list))
  (call method: (identifier))
  (call method: (identifier) arguments: (argument_list))

  (call
    receiver: (true)
    method: (identifier))

  (call
    receiver: (call
      method: (identifier))
    method: (identifier))

  (call
    method: (identifier)
    arguments: (argument_list (identifier)))

  (call
    method: (identifier)
    arguments: (argument_list
      (call
        method: (identifier)
        arguments: (argument_list (integer)))))

  (call
    receiver: (call
      receiver: (call
        method: (identifier))
      method: (identifier))
    method: (identifier))

  (call
    method: (identifier)
    arguments: (argument_list
      (call
        receiver: (identifier)
        method: (identifier))))

  (call
    method: (identifier)
    arguments: (argument_list
      (call
        method: (identifier)
        arguments: (argument_list
          (call
            method: (identifier)
            arguments: (argument_list))))))

  (call
    method: (identifier)
    arguments: (argument_list
      (call
        receiver: (identifier)
        (comment)
        (comment)
        (comment)
        (comment)
        method: (identifier))))
  (comment))

====================================
method calls with multiple arguments
====================================

puts true, -1, nil

puts false,
  0

puts(true, false, nil)
puts(true, false, nil,)
puts(
  true,
  false,
  nil,
)

puts (), ()

---
(source_file
  (call
    method: (identifier)
    arguments: (argument_list
      (true) (integer) (nil)))

  (call
    method: (identifier)
    arguments: (argument_list
      (false) (integer)))

  (call
    method: (identifier)
    arguments: (argument_list (true) (false) (nil)))
  (call
    method: (identifier)
    arguments: (argument_list (true) (false) (nil)))
  (call
    method: (identifier)
    arguments: (argument_list (true) (false) (nil)))

  (call
    method: (identifier)
    arguments: (argument_list (nil) (nil))))

===============
splat arguments
===============
puts *a
puts*a

pp *a, 2, *{3}

pp(*a+b, *c*d)
---
(source_file
  (call
    method: (identifier)
    arguments: (argument_list
      (splat
        (identifier))))
  (op_call
    receiver: (identifier)
    operator: (operator)
    argument: (identifier))

  (call
    method: (identifier)
    arguments: (argument_list
      (splat
        (identifier))
      (integer)
      (splat
        (tuple
          (integer)))))

  (call
    method: (identifier)
    arguments: (argument_list
      (splat
        (op_call
          receiver: (identifier)
          operator: (operator)
          argument: (identifier)))
      (splat
        (op_call
          receiver: (identifier)
          operator: (operator)
          argument: (identifier))))))

======================
double splat arguments
======================
puts ** kwargs
puts **kwargs
puts**kwargs

pp **{a: 1, "b": 2.0}, **{c: nil}
---
(source_file
  (op_call
    receiver: (identifier)
    operator: (operator)
    argument: (identifier))
  (call
    method: (identifier)
    arguments: (argument_list
      (double_splat
        (identifier))))
  (op_call
    receiver: (identifier)
    operator: (operator)
    argument: (identifier))

  (call
    method: (identifier)
    arguments: (argument_list
      (double_splat
        (named_tuple
          (named_tuple_entry (identifier) (integer))
          (named_tuple_entry (string) (float))))
      (double_splat
        (named_tuple
          (named_tuple_entry (identifier) (nil)))))))

================
plain assignment
================

a = 1.0

b =
c=
2

d=-0.zero?

(e=1f32)
.to_s

---

(source_file
  (assign
    lhs: (identifier)
    rhs: (float))

  (assign
    lhs: (identifier)
    rhs: (assign
      lhs: (identifier)
      rhs: (integer)))

  (assign
    lhs: (identifier)
    rhs: (call
      receiver: (integer)
      method: (identifier)))

  (call
    receiver: (assign
      lhs: (identifier)
      rhs: (float))
    method: (identifier)))

===================
constant assignment
===================

A = 1.0

B =
::C=
2

D::E=-0.zero?

---
(source_file
  (const_assign
    lhs: (constant)
    rhs: (float))

  (const_assign
    lhs: (constant)
    rhs: (const_assign
      lhs: (constant)
      rhs: (integer)))

  (const_assign
    lhs: (constant)
    rhs: (call
      receiver: (integer)
      method: (identifier))))

=================
method assignment
=================

::A.b = 1

self
.var =
true

c.foo.bar = d.baz!.quz = 8

---

(source_file
  (assign
    lhs: (assign_call
      receiver: (constant)
      method: (identifier))
    rhs: (integer))

  (assign
    lhs: (assign_call
      receiver: (self)
      method: (identifier))
    rhs: (true))

  (assign
    lhs: (assign_call
      receiver: (call
        receiver: (identifier)
        method: (identifier))
      method: (identifier))
    rhs: (assign
      lhs: (assign_call
        receiver: (call
          receiver: (identifier)
          method: (identifier))
        method: (identifier))
      rhs: (integer))))

=========================
assignment with modifiers
=========================
a = 5 if c

foo.bar = 0.8 if true if false

baz = 7 unless qux?
---
(source_file
  (modifier_if
    then: (assign
      lhs: (identifier)
      rhs: (integer))
    cond: (identifier))

  (modifier_if
    then: (modifier_if
      then: (assign
        lhs: (assign_call
          receiver: (identifier)
          method: (identifier))
        rhs: (float))
      cond: (true))
    cond: (false))

  (modifier_unless
    then: (assign
      lhs: (identifier)
      rhs: (integer))
    cond: (call
      method: (identifier))))

===============
while and until
===============

while true; end

while 1
next; end

until a.nil?
  a = 2
  until a
    break
  end
end

----

(source_file
  (while
    condition: (true))

  (while
    condition: (integer)
    (next))

  (until
    condition: (call
      receiver: (identifier)
      method: (identifier))
    (assign
      lhs: (identifier)
      rhs: (integer))
    (until
      condition: (identifier)
      (break))))

============
begin blocks
============

begin 1 end
begin;2;end

begin
  begin
  end
end
begin begin end end

begin
  1
rescue
  2
end

begin 3; rescue; 4 end

begin
  5; rescue a;
  6; end

begin
  7
rescue Exception; 8
end

begin 9
rescue err : FooError | BarError
end

---

(source_file
  (begin_block body: (integer))
  (begin_block body: (integer))

  (begin_block body: (begin_block))
  (begin_block body: (begin_block))

  (begin_block
    body: (integer)
    rescue: (rescue_block
      body: (integer)))

  (begin_block
    body: (integer)
    rescue: (rescue_block
      body: (integer)))

  (begin_block
    body: (integer)
    rescue: (rescue_block
      variable: (identifier)
      body: (integer)))

  (begin_block
    body: (integer)
    rescue: (rescue_block
      type: (constant)
      body: (integer)))

  (begin_block
    body: (integer)
    rescue: (rescue_block
      variable: (identifier)
      type: (union_type (constant) (constant)))))

=========================
binary additive operators
=========================

1 + 2.0

a &+ b! - C

D &-
  (E)

puts "a" + "b".upcase

---

(source_file
  (op_call
    receiver: (integer)
    operator: (operator)
    argument: (float))

  (op_call
    receiver: (op_call
      receiver: (identifier)
      operator: (operator)
      argument: (call
        method: (identifier)))
    operator: (operator)
    argument: (constant))

  (op_call
    receiver: (constant)
    operator: (operator)
    argument: (constant))

  (call
    method: (identifier)
    arguments: (argument_list
      (op_call
        receiver: (string)
        operator: (operator)
        argument: (call
          receiver: (string)
          method: (identifier)))))

    )

========================
unary additive operators
========================

puts + 2
puts +2
puts+2
puts(+ 2)

a! - 1
b? -1
c-
1
d_ (- 2)

+-+0
+- 0.3

1-
+2
1-+ 2

- 8u8.to_i8

---
(source_file
  (op_call
    receiver: (identifier)
    operator: (operator)
    argument: (integer))
  (call
    method: (identifier)
    arguments: (argument_list (integer)))
  (op_call
    receiver: (identifier)
    operator: (operator)
    argument: (integer))
  (call
    method: (identifier)
    arguments: (argument_list
      (op_call
        operator: (operator)
        receiver: (integer))))

  (op_call
    receiver: (call
      method: (identifier))
    operator: (operator)
    argument: (integer))
  (call
    method: (identifier)
    arguments: (argument_list (integer)))
  (op_call
    receiver: (identifier)
    operator: (operator)
    argument: (integer))
  (call
    method: (identifier)
    arguments: (argument_list
      (op_call
        operator: (operator)
        receiver: (integer))))

  (op_call
    operator: (operator)
    receiver: (op_call
      operator: (operator)
      receiver: (integer)))
  (op_call
    operator: (operator)
    receiver: (op_call
      operator: (operator)
      receiver: (float)))

  (op_call
    receiver: (integer)
    operator: (operator)
    argument: (integer))
  (op_call
    receiver: (integer)
    operator: (operator)
    argument: (op_call
      operator: (operator)
      receiver: (integer)))

  (op_call
    operator: (operator)
    receiver: (call
      receiver: (integer)
      method: (identifier))))

========================
multiplicative operators
========================
1 * 2 &* 3.0 / 4.5 // 6 % asdf

pp 2*7..3/1.5

pp 7 +
  4.0 //
    3

---
(source_file
  (op_call
    receiver: (op_call
      receiver: (op_call
        receiver: (op_call
          receiver: (op_call
            receiver: (integer)
            operator: (operator)
            argument: (integer))
          operator: (operator)
          argument: (float))
        operator: (operator)
        argument: (float))
      operator: (operator)
      argument: (integer))
    operator: (operator)
    argument: (identifier))

  (call
    method: (identifier)
    arguments: (argument_list
      (range
        begin: (op_call
          receiver: (integer)
          operator: (operator)
          argument: (integer))
        operator: (operator)
        end: (op_call
          receiver: (integer)
          operator: (operator)
          argument: (float)))))

  (call
    method: (identifier)
    arguments: (argument_list
      (op_call
        receiver: (integer)
        operator: (operator)
        argument: (op_call
          receiver: (float)
          operator: (operator)
          argument: (integer))))))

=====================
exponential operators
=====================
a ** B &** 7

puts 2 **
10

42.0 % 2 ** EXP
---
(source_file
  (op_call
    receiver: (identifier)
    operator: (operator)
    argument: (op_call
      receiver: (constant)
      operator: (operator)
      argument: (integer)))

  (call
    method: (identifier)
    arguments: (argument_list
      (op_call
        receiver: (integer)
        operator: (operator)
        argument: (integer))))

  (op_call
    receiver: (float)
    operator: (operator)
    argument: (op_call
      receiver: (integer)
      operator: (operator)
      argument: (constant))))

===============
shift operators
===============
a << "asdf"
b << c >> D

array << 1 << 2
array << (13 >> 2)
---
(source_file
  (op_call
    receiver: (identifier)
    operator: (operator)
    argument: (string))
  (op_call
    receiver: (op_call
      receiver: (identifier)
      operator: (operator)
      argument: (identifier))
    operator: (operator)
    argument: (constant))

  (op_call
    receiver: (op_call
      receiver: (identifier)
      operator: (operator)
      argument: (integer))
    operator: (operator)
    argument: (integer))
  (op_call
    receiver: (identifier)
    operator: (operator)
    argument: (op_call
      receiver: (integer)
      operator: (operator)
      argument: (integer))))

========================
binary/bitwise operators
========================
~1 ^ 5

a ^ b | c

6 & a | 1 << AMT

pp [1, 2, 3] | [4, 5, 6] & [1, 4]
---
(source_file
  (op_call
    receiver: (op_call
      operator: (operator)
      receiver: (integer))
    operator: (operator)
    argument: (integer))

  (op_call
    receiver: (op_call
      receiver: (identifier)
      operator: (operator)
      argument: (identifier))
    operator: (operator)
    argument: (identifier))

  (op_call
    receiver: (op_call
      receiver: (integer)
      operator: (operator)
      argument: (identifier))
    operator: (operator)
    argument: (op_call
      receiver: (integer)
      operator: (operator)
      argument: (constant)))

  (call
    method: (identifier)
    arguments: (argument_list
      (op_call
        receiver: (array
          (integer) (integer) (integer))
        operator: (operator)
        argument: (op_call
          receiver: (array
            (integer) (integer) (integer))
          operator: (operator)
          argument: (array
            (integer) (integer)))))))

=================
logical operators
=================
!thingy
a.nil? || b
foo && bar

!
true ||
false

a || b && c

d && e || f && g
----
(source_file
  (not (identifier))
  (or (call receiver: (identifier) method: (identifier)) (identifier))
  (and (identifier) (identifier))

  (or (not (true)) (false))

  (or (identifier) (and (identifier) (identifier)))

  (or (and (identifier) (identifier)) (and (identifier) (identifier))))

=============
if/elsif/else
=============
if true;end

if ABC
  return 5
end

if cond1
elsif cond2
elsif cond3
else
end

if a "a"; puts "a" elsif b "b"; puts "b" else puts "c" end

if you
  puts "shouldn't"
else if DO
    puts "this"
  end
end

---
(source_file
  (if cond: (true))

  (if
    cond: (constant)
    then: (then
      (return (integer))))

  (if
    cond: (identifier)
    else: (elsif
      cond: (identifier)
      else: (elsif
        cond: (identifier)
        else: (else))))

  (if
    cond: (call
      method: (identifier)
      arguments: (argument_list
        (string)))
    then: (then
      (call
        method: (identifier)
        arguments: (argument_list
          (string))))
    else: (elsif
      cond: (call
        method: (identifier)
        arguments: (argument_list
          (string)))
      then: (then
        (call
          method: (identifier)
          arguments: (argument_list
            (string))))
      else: (else
        (call
          method: (identifier)
          arguments: (argument_list
            (string))))))

  (if
    cond: (identifier)
    then: (then
      (call
        method: (identifier)
        arguments: (argument_list
          (string))))
    else: (else
      (if
        cond: (constant)
        then: (then
          (call
            method: (identifier)
            arguments: (argument_list
              (string))))))))

======
unless
======
unless a; end

unless true
  pp "asdf"
else
  pp "hjkl"
end
---
(source_file
  (unless cond: (identifier))

  (unless
    cond: (true)
    then: (then
      (call
        method: (identifier)
        arguments: (argument_list
          (string))))
    else: (else
      (call
        method: (identifier)
        arguments: (argument_list
          (string))))))

==========
ternary if
==========
thingy? ? 1 : 2.0

puts true ?
"a"
:
# something
'b'

ans = foo ? "foo" : bar ? "bar" : nil
---
(source_file
  (conditional
    cond: (call method: (identifier))
    then: (integer)
    else: (float))

  (call
    method: (identifier)
    arguments: (argument_list
      (conditional
        cond: (true)
        then: (string)
        (comment)
        else: (char))))

  (assign
    lhs: (identifier)
    rhs: (conditional
      cond: (identifier)
      then: (string)
      else: (conditional
        cond: (identifier)
        then: (string)
        else: (nil)))))

============
if modifiers
============
def foo
  return 7 if foo?
  puts 'c' if bar
  8 if
    if
      true
        "yes"
      else
        "no"
      end

  puts i nil
  puts if? true
  puts iff false
end
---
(source_file
  (method_def
    name: (identifier)
    (modifier_if
      then: (return (integer))
      cond: (call
        method: (identifier)))
    (modifier_if
      then: (call
        method: (identifier)
        arguments: (argument_list
          (char)))
      cond: (identifier))
    (modifier_if
      then: (integer)
      cond: (if
        cond: (true)
        then: (then (string))
        else: (else (string))))

    (call
      method: (identifier)
      arguments: (argument_list
        (call
          method: (identifier)
          arguments: (argument_list
            (nil)))))
    (call
      method: (identifier)
      arguments: (argument_list
        (call
          method: (identifier)
          arguments: (argument_list
            (true)))))
    (call
      method: (identifier)
      arguments: (argument_list
        (call
          method: (identifier)
          arguments: (argument_list
            (false)))))))

================
unless modifiers
================
def foo
  return 7 unless foo?
  puts 'c' unless bar
  8 unless
    unless
      true
        "yes"
      else
        "no"
      end

  puts unles nil
  puts unless? true
  puts unlesss false
end
---

(source_file
  (method_def
    name: (identifier)
    (modifier_unless
      then: (return (integer))
      cond: (call
        method: (identifier)))
    (modifier_unless
      then: (call
        method: (identifier)
        arguments: (argument_list
          (char)))
      cond: (identifier))
    (modifier_unless
      then: (integer)
      cond: (unless
        cond: (true)
        then: (then (string))
        else: (else (string))))

    (call
      method: (identifier)
      arguments: (argument_list
        (call
          method: (identifier)
          arguments: (argument_list
            (nil)))))
    (call
      method: (identifier)
      arguments: (argument_list
        (call
          method: (identifier)
          arguments: (argument_list
            (true)))))
    (call
      method: (identifier)
      arguments: (argument_list
        (call
          method: (identifier)
          arguments: (argument_list
            (false)))))))


========================
calls with do/end blocks
========================

a do end

a b do end

a b() do end

a b c do
d do end; f g do end
end

a (b do 1 end) do 2 end

---

(source_file
  (call
    method: (identifier)
    block: (block))

  (call
    method: (identifier)
    arguments: (argument_list
      (identifier))
    block: (block))

  (call
    method: (identifier)
    arguments: (argument_list
      (call
        method: (identifier)
        arguments: (argument_list)))
    block: (block))

  (call
    method: (identifier)
    arguments: (argument_list
      (call
        method: (identifier)
        arguments: (argument_list
          (identifier))
        ))
    block: (block
      (call
        method: (identifier)
        block: (block))

      (call
        method: (identifier)
        arguments: (argument_list
          (identifier))
        block: (block))))

  (call
    method: (identifier)
    arguments: (argument_list
      (call
        method: (identifier)
        block: (block
          (integer))))
    block: (block
      (integer))))

====================
calls with {} blocks
====================

a {}
a() {}

a 1 { 2 }
a(1) { 2 }

a { b { c } }

a b c { 1 }
a b c do 1 end

a b { 1 } do 2 end

a {
  b do
    1
  end
}

a do
  b { 2
  } end

a b { 1 } do 2 end

a b { 1 } { 2 }
a(b { 1 }) { 2 }

a 1, {2, b { 4 }} { 3 }

---

(source_file
  (call
    method: (identifier)
    block: (block))

  (call
    method: (identifier)
    arguments: (argument_list)
    block: (block))

  (call
    method: (identifier)
    arguments: (argument_list
      (integer))
    block: (block
      (integer)))

  (call
    method: (identifier)
    arguments: (argument_list
      (integer))
    block: (block
      (integer)))

  (call
    method: (identifier)
    block: (block
      (call
        method: (identifier)
        block: (block
          (identifier)))))

  (call
    method: (identifier)
    arguments: (argument_list
      (call
        method: (identifier)
        arguments: (argument_list
          (call
            method: (identifier)
            block: (block
              (integer)))))))

  (call
    method: (identifier)
    arguments: (argument_list
      (call
        method: (identifier)
        arguments: (argument_list
          (identifier))))
    block: (block
      (integer)))

  (call
    method: (identifier)
    arguments: (argument_list
      (call
        method: (identifier)
        block: (block
          (integer))))
    block: (block
      (integer)))

  (call
    method: (identifier)
    block: (block
      (call
        method: (identifier)
        block: (block
          (integer)))))

  (call
    method: (identifier)
    block: (block
      (call
        method: (identifier)
        block: (block
          (integer)))))

  (call
    method: (identifier)
    arguments: (argument_list
      (call
        method: (identifier)
        block: (block
          (integer))))
    block: (block
      (integer)))

  (call
    method: (identifier)
    arguments: (argument_list
      (call
        method: (identifier)
        block: (block
          (integer))))
    block: (block
      (integer)))

  (call
    method: (identifier)
    arguments: (argument_list
      (call
        method: (identifier)
        block: (block
          (integer))))
    block: (block
      (integer)))

  (call
    method: (identifier)
    arguments: (argument_list
      (integer)
      (tuple
        (integer)
        (call
          method: (identifier)
          block: (block
            (integer)))))
    block: (block
      (integer))))
